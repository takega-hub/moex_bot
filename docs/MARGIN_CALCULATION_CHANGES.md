# Изменения в расчете ГО: удаление словаря из алгоритма

## Обзор изменений

Словарь `MARGIN_PER_LOT` больше **не используется** в расчетах гарантийного обеспечения.
Все значения теперь рассчитываются **динамически** из данных API по формуле.

---

## Что изменилось

### 1. Функция `get_margin_for_position`

**Было:**
- Приоритет 1: Проверка словаря `MARGIN_PER_LOT`
- Приоритет 2: Автоматический расчет из похожих инструментов (через словарь)
- Приоритет 3: Расчет через `POINT_VALUE` словарь
- Приоритет 4: Fallback (процент от стоимости)

**Стало:**
- Приоритет 1: Расчет через переданный `point_value` (min_price_increment из API)
- Приоритет 2: Расчет через `POINT_VALUE` словарь (если есть)
- Приоритет 3: Fallback (процент от стоимости)

**Изменения:**
- ✅ Удалена проверка словаря `MARGIN_PER_LOT`
- ✅ Удалена логика с похожими инструментами (использовала словарь)
- ✅ Добавлен параметр `point_value` для прямого расчета
- ✅ Удален параметр `auto_calculate_point_value_flag`

### 2. Функция `get_margin_per_lot_from_api_data`

**Было:**
- Приоритет 1: Проверка словаря `MARGIN_PER_LOT`
- Приоритет 2: Формула `point_value × price × dlong/dshort`

**Стало:**
- Только формула: `point_value × price × dlong/dshort`

**Изменения:**
- ✅ Удалена проверка словаря
- ✅ Функция теперь всегда рассчитывает через формулу

### 3. Словарь `MARGIN_PER_LOT`

**Статус:** Оставлен для совместимости, но **не используется** в расчетах.

**Комментарий в коде:**
```python
# Справочник гарантийного обеспечения за лот (НЕ ИСПОЛЬЗУЕТСЯ в расчетах)
# Оставлен для совместимости и справки
# ВАЖНО: Все значения рассчитываются динамически из API через формулу
MARGIN_PER_LOT: Dict[str, float] = {
    # ...
}
```

---

## Формула расчета

### Основная формула

```python
ГО = point_value × current_price × dshort  # для SHORT
ГО = point_value × current_price × dlong  # для LONG
```

**Где:**
- `point_value` = `min_price_increment` из API (стоимость пункта)
- `current_price` = текущая цена инструмента
- `dlong`/`dshort` = коэффициенты из API

### Пример для TBH6

```python
point_value = 1.0  # min_price_increment
current_price = 3531.0  # ₽
dshort = 0.25

ГО = 1.0 × 3531.0 × 0.25 = 882.75 ₽
```

**Результат:** Почти совпадает с терминалом (885.75 ₽), разница 0.34%

---

## Обновленные файлы

### `bot/margin_rates.py`

1. ✅ Удалена проверка словаря из `get_margin_for_position`
2. ✅ Удалена проверка словаря из `get_margin_per_lot_from_api_data`
3. ✅ Удалена логика с похожими инструментами
4. ✅ Обновлены комментарии и документация

### `find_optimal_instruments.py`

1. ✅ Обновлен вызов `get_margin_for_position` с передачей `point_value`

---

## Преимущества

1. ✅ **Динамический расчет** - всегда актуальные значения из API
2. ✅ **Нет необходимости обновлять словарь** вручную
3. ✅ **Единая формула** для всех инструментов
4. ✅ **Меньше кода** - упрощена логика

---

## Обратная совместимость

- ✅ Словарь `MARGIN_PER_LOT` оставлен для справки
- ✅ Функция `update_margin_per_lot` оставлена (но не используется)
- ✅ Функция `auto_calculate_point_value` оставлена (может использоваться отдельно)

---

## Рекомендации

1. ✅ **Используйте формулу** для всех новых инструментов
2. ✅ **Проверяйте точность** через `find_margin_formula.py`
3. ⚠️ **Если формула не работает** (разница > 1%), проверьте данные API

---

## Пример использования

```python
from bot.margin_rates import get_margin_for_position

# Расчет ГО для 1 лота
margin = get_margin_for_position(
    ticker="TBH6",
    quantity=1.0,
    entry_price=3531.0,
    lot_size=1.0,
    dlong=0.25,
    dshort=0.25,
    is_long=False,
    point_value=1.0  # min_price_increment из API
)

# Результат: 882.75 ₽
```

---

## Миграция

Если у вас есть код, который использует словарь:

**Было:**
```python
if ticker in MARGIN_PER_LOT:
    margin = MARGIN_PER_LOT[ticker]
```

**Стало:**
```python
margin = get_margin_for_position(
    ticker=ticker,
    quantity=1.0,
    entry_price=current_price,
    dlong=dlong,
    dshort=dshort,
    point_value=min_price_increment
)
```

---

## Вывод

✅ **Словарь удален из алгоритма расчета**
✅ **Все значения рассчитываются динамически из API**
✅ **Формула работает правильно** (проверено на TBH6)
